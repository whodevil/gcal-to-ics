/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package gcal.to.ics.app

import com.google.api.client.auth.oauth2.Credential
import com.google.api.client.extensions.java6.auth.oauth2.AuthorizationCodeInstalledApp
import com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport
import com.google.api.client.http.javanet.NetHttpTransport
import com.google.api.client.json.gson.GsonFactory
import com.google.api.client.util.DateTime
import com.google.api.client.util.store.FileDataStoreFactory
import com.google.api.services.calendar.Calendar
import com.google.api.services.calendar.CalendarScopes
import com.google.api.services.calendar.model.Event
import com.google.api.services.calendar.model.Events
import java.io.File
import java.io.InputStreamReader
import java.time.format.DateTimeFormatter
import java.util.*


data class Configuration(
        val credentialsPath: String = "google_secrets.json",
        val tokensPath: String = "tokens",
        val author: String,
        val fileTags: String,
        val category: String,
        val email: String,
) {
    constructor(properties: Properties) :  this(
            author = properties["author"].toString(),
            fileTags = properties["fileTags"].toString(),
            category = properties["category"].toString(),
            email = properties["email"].toString()
    )
}

fun main() {
    val configuration = configuration()
    val events = fetchEvents(configuration)
    val items = events.items
    val stringBuilder = StringBuilder()
    fileHeaders(stringBuilder, configuration)
    if (items.isEmpty()) {
        println("No upcoming events found.")
    } else {
        for (event in items) {
            if (event.description == null) continue
            buildOrgEvent(stringBuilder, event)
            File("work.org").writeText(stringBuilder.toString())
            print(stringBuilder)
        }
    }
}

private fun configuration(): Configuration {
    val properties = Properties()
    properties.load(File("configuration.properties").inputStream())
    val configuration = Configuration(properties)
    return configuration
}

private fun fileHeaders(stringBuilder: StringBuilder, configuration: Configuration) {
    stringBuilder.append("""
        #+TITLE:            Work
        #+AUTHOR:       ${configuration.author}
        #+EMAIL:           ${configuration.email}
        #+CATEGORY:   ${configuration.category}
        #+STARTUP:     hidestars
        #+STARTUP:     overview
        #+FILETAGS:    ${configuration.fileTags}
    
    """.trimIndent())
}

private fun buildOrgEvent(stringBuilder: StringBuilder, event: Event) {
    //            """:
//                  :LOGBOOK:
//                  CLOCK: [2018-12-29 Sat 16:30]--[2018-12-29 Sat 17:30] =>  0:00
//                  :END
//                <2016-08-08 Mon +1y>
//                """
    stringBuilder.append("\n")
    orgEventProperties(stringBuilder, event)
    timeline(event, stringBuilder)
    attendees(event, stringBuilder)
    description(event, stringBuilder)
    hangout(event, stringBuilder)
}

private fun orgEventProperties(stringBuilder: StringBuilder, event: Event) {
    stringBuilder.append("""
                * ${event.summary}
                  :PROPERTIES:
                  :ID:        ${event.iCalUID}
                  :ATTENDING: ATTENDING
                  :END:
                  """.trimIndent())
}

private fun fetchEvents(configuration: Configuration): Events {
    val jsonFactory = GsonFactory.getDefaultInstance()
    val transport = GoogleNetHttpTransport.newTrustedTransport()
    val credentials = fetchCredentials(configuration, jsonFactory, transport)
    val service = Calendar.Builder(transport, jsonFactory, credentials).setApplicationName("calendar reader").build()
    val now = DateTime(System.currentTimeMillis())
    return service.events().list("primary").setMaxResults(100).setTimeMin(now).setOrderBy("startTime").setSingleEvents(true).execute()
}

private fun fetchCredentials(configuration: Configuration, jsonFactory: GsonFactory, transport: NetHttpTransport): Credential {
    val credentialsFile = File(configuration.credentialsPath)
    val tokensPath = File(configuration.tokensPath)
    val clientSecrets = GoogleClientSecrets.load(jsonFactory, InputStreamReader(credentialsFile.inputStream()))
    val scopes = listOf(CalendarScopes.CALENDAR_READONLY)
    val flow = GoogleAuthorizationCodeFlow.Builder(transport, jsonFactory, clientSecrets, scopes).setDataStoreFactory(FileDataStoreFactory(tokensPath)).setAccessType("offline").build()
    val receiver = LocalServerReceiver.Builder().setPort(8888).build()
    return AuthorizationCodeInstalledApp(flow, receiver).authorize("user")
}

private fun timeline(event: Event, stringBuilder: StringBuilder) {
    if (event.start.dateTime != null) {
        val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd EEE HH:mm");
        val startTime = formatter.format(DateTimeFormatter.ISO_DATE_TIME.parse(event.start.dateTime.toStringRfc3339()))
        val endTime = formatter.format(DateTimeFormatter.ISO_DATE_TIME.parse(event.end.dateTime.toStringRfc3339()))
        stringBuilder.append("\n<$startTime>--<$endTime>")
    } else {
        stringBuilder.append("\n<${event.start.date}>")
    }
}

private fun attendees(event: Event, stringBuilder: StringBuilder) {
    if (event.attendees != null) {
        val attendees = event.attendees.map {
            val attending = if (it.responseStatus == "accepted") "X" else " "
            " - [$attending] ${it.email}"
        }.joinToString(separator = "\n")
        stringBuilder.append("\n** Attendees\n")
        stringBuilder.append(attendees)
    }
}

private fun description(event: Event, stringBuilder: StringBuilder) {
    if (event.description != null) {
        stringBuilder.append("\n** Description\n")
        stringBuilder.append(event.description.trim().replace("<br>", "\n").replace("<p>", "").replace("</p>", "").replace("<span>", "").replace("</span>", "").replace("<strong>", "").replace("</strong>", ""))
    }
}

private fun hangout(event: Event, stringBuilder: StringBuilder) {
    if (event.hangoutLink != null) {
        stringBuilder.append("\n** [[${event.hangoutLink}][Google Hangout]]")
    }
}
